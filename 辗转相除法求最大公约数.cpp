# include <stdio.h>  //辗转相除法求最大公约数 

int main(void)
{
	long int m, n, a, i, t;
	
	scanf("%ld,%ld", &m, &n);
	
	if(m<n)  //确保m是比较大的那个数 
	{
		t = m;
		m = n;
		n = t;
	}
	
	while (n != 0) 
	{
		t = m % n; //取完余后，取余后的那个数肯定是要小于较小的那个数n的   
		m = n;  //取完余后，问题就变成了n和取余数的最大公约数了，所以这里要确保m是那个比较大的数：n，n是那个比较小的数：取余数 
		n = t;  //判断结束的标志就是取余后的数字为0，由于取余数是t，而20行直到t和n都会是0，则输出的应该是非零的m 
	}
    printf("%d", m);
    
	return 0;
}

//首先介绍下更相减损术的原理，假设有两个数161和63，我们要求这两个数的最大公因数，不妨假定这个最大公因数为m，我们可以将较大的数161看成63+98，
//63与98的和161可以被m整除，其中63也可以被m整除，自然98可以被m整除；
//所以这个问题就转换为求98和63的最大公因数m（和上面m相等）
//将98看成63+35，其中63可以被m整除，和98也能被m整除，故35也可以被m整除；
//所以问题进一步转换为求35和63的最大公因数m（和上面m相等）
//同理转换为求 (63-35)=>28和35 的最大公因数
//然后转换为求28和7的最大公因数
//…（一直减呀减）
//后来转换为求7和7的最大公因数
//最后转换为求7和0的最大公因数
//输出第一个数字即可；这就是相减损术的原理
//我们发现求28和7的最大公约数，一直减7，一直减7…减到不能减为止。这个不断减7的过程就是除7求余数（即%7）
//这样我们可以将相减损术优化成辗转相除法，上面给出了思考过程，有兴趣可以百度严谨的证明过程
//――――――――――――――――
//版权声明：本文为CSDN博主「哈哈哈哈嘻哈从」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
//原文链接：https://blog.csdn.net/weixin_43886797/article/details/85569998
