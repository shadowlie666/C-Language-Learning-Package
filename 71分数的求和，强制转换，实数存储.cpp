# include <stdio.h>  //程序的目的是求1/2 + 1/3 + 1/4 + 1/5.....+ 1/100的和 

int main(void)
{
	int i;
	float sum = 0; //由目的易知，最后sum的值一定是一个小数，故用float定义 
	
	for(i = 1; i <= 100; i++)
		sum = sum + 1.0/i;  //整形除以整形，输出结果一定是整形，故这里用1.0引入一个实数，这样计算机就不会把1/2直接舍去小数位看成1/2=0了 
	printf("sum = %f\n", sum, i);  //既然使用float定义的就别忘了用%f输出 
	
	return 0;
}
//假如说第九行那里没有用1.0而是用1的话，由于i是用int定义的，那么就变成了整形除以整形的格式，这时候计算机是会默认舍去小数位的，也就是输入0.5计算机会输出为0
//注意计算机也不会给你四舍五入，但如果把1改成了1.0，就相当于1.0是个实数，就变成了实数除以整形的格式，此时计算机就会保留小数了，输入0.5计算机就会输出0.5

//除了将1改成1.0外，还可以使用强制转换实现该程序，格式为sum = sum + 1/（float）（i），意思就是将i变量再这条命令中强制由整形变量改为实数变量 
//这样的话，当i的值为3时，它就会被强制转换为3.0，达到式子变成整形除以实数的格式，这样也可以把小数点保留下来，（先将i赋值，再执行float，再进行除法运算） 
//注意，不能写成（float）（1/i），但可以写成（float）（1）/i，因为前者是先执行右边括号，当i为2时，右边括号1/2为整形除以整形，计算机会认为1/2=0
//然后再执行左边括号，将0强制转换为浮点数0.000，这样程序就出错了，记住，执行顺序先是右边括号执行，再是左边括号执行，再是其他命令 

//解释一下计算机如何存储实数的，计算机会默认把6.2999看成是我们认为的6.3，因为6.3-6.29999无限趋近于0，超过了计算机的精度范围，这时他就会默认6.3和6.2999相等
//所以你要是定义float i，到时候万一储存的是6.2999，他就小于6.3了，可能就会导致限制数无法实现 
//因此不能直接定义时就把i定义为浮点数，参与循环的变量要用整形定义，但参与循环的某个步骤中可以将其强制转换为浮点数
//比如，当i加到100时，如果你是定义i为浮点数，那么计算机很可能将你输入的100以100.0001输出，而100.0001>100，本来100还要执行一次循环的，但计算机将100存储错了
//便会导致程序少执行一次循环

//为什么3经过强制转换后会变成3.0：因为计算机将3强制转换为浮点数后要存储他，但是3本身不是浮点数，所以计算机要找一个和3一样的数字存储
//由上面解释实数存储的原理可知，计算机会认为3.00001或者3.0之类的数和3相等，所以计算机很可能会将浮点数形式的3以3.0的形式存储 
 
