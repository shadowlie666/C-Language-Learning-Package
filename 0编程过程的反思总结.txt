1.结尾结束符的分号一定要是英文的分号;   不能是中文的分号；
2.char 是字符变量,而 int 是整型变量，也就是某变量被赋予的值为字符时，用char，某变量被赋予的值为整形数字时（不包括实数），用int
3.逗号的右边要敲空格，等号的两边要敲空格
4.运用int，char等定义时要一次定义完，要写成int i，k     不能写成int i，int k 
5.且命题&&，要两个都是真才是真命题
   或命题||，只要有一个是真那么他就是真命题
6.只要变量的值没有给赋予0，那么这个变量就是一个真命题
7.int-整形-4字节-%d、%h
   long int-整形-8字节-%ld
   char-字符-1字节-%c、%s
   float-浮点数-4字节-%f
   double-浮点数-8字节-%lf
8.一个英文字母，一个数字为一个字节，int只能存4字节则若输入123456只会输出1234
   同样的，char只能存放一个字节，若输入df，以%c输出则只有d，但若以%s输出的话，输出结果为df
9.输出字符串的注意事项：不使用scanf时，定义时要加上[]，如char i[]=df;
10.当我们用scanf()  用到%s  时 它会自动的在最后加 '\0'
     当我们用printf() 用到%s  时 它会一个接一个挨着输出, 直到遇见'\0'才中止
11.对计算机来说，0就是一个假命题的字符，if（0）本身就是假的
12.非输入控制符都是原样输入，不能由人工输入改变，也就是我们输入的数字只能改变%d【3839】
13.scanf里面的逗号一定是用英文的逗号
     用int，char等定义时要一次定义完，要写成int i，k     不能写出int i，int k 【4041】
14.当你输入123m的时候，由于你的i是用int定义的，所以只会输出为123，但是多余的m并不会自动删除，他会被赋到能被赋予字符的变量上。
     当你输入的值不小心打多一个m时（123m），你还想第二次输入，就需要用到while循环语句
	while( (p = getchar())  != '\n' )     continue是重新执行循环，但这个循环已经不成立了，那么就跳过这个循环执行continue下面的语句
	continue;                                        【41】
15.由于1>2就已经足够判断m的输出值了，系统也不会继续执行后面的k=9的命令，所以k的值就还是一开始的6 【42-44】
16.使用scanf输出字符串时：devc++中输出字符串不受[]的限制，即使你写了[3]，同样可以输出4字节的字符串【字符串的输入与输出1】
     前提：一定是使用scanf输出字符串的时候才不受[]长度限制，如果是直接定义赋值输出的话是会受[]的限制的
     即使是使用scanf来输入字符串，也不能省略[]及里面的数字
17.直接定义赋值输出字符串时，一定要写成char ch[5] = "asdf";    不能写成char ch[5];   ch = "asdf";【字符串的输入与输出2】
     直接赋值字符串输出时，字符串一定要加上“”，同时[]不能省略，括号里面的数字也要设定好要比你输出的字符串要大 
     因为你输入的值他会自动在后面加个\0表示结束符，因此你实际的字符串长度会多余你输入的值，比如你输入asdf，计算机实际接收到的是asdf\0，
18.当输入的字符串需要加空格时，用gets函数输入，涉及输入值无空格时，使用scanf输入 【字符串的输入与输出3】
19.易犯问题：当使用printf输出时，不要忘记输出完要写上变量名称   printf("a = %s\n b = %s\n", a, b);
                      使用scanf输入时，输入单字符和数字时要加上&，输入字符串时不用&
                      定义，赋值，输入，输出之类的都不要忘记在结束时打上分号
20.if不需要分号，但if后面一定要有括号表示你假设的内容 ，if下面那行写上假设成立的话要执行的命令 
     if后面的括号若直接是一个数字的话计算机还是会默认if（0）为假，if（66）为真，if（0==0）为真。【52】
21.if默认只能控制一个语句（只能控制他下面那个语句的是否执行）。如果要让if控制两个语句 ，则要使用大括号（这样才能控制他下面的多个语句是否执行）
     注意格式问题，大括号一定要成双成对，if的大括号与main的大括号不能在同一竖列 【53】
22.给文件命名的时候不要打小数点，不然文件名后缀默认的.cpp系统就不会给你加上，要你自己去加，不加的话你写的程序就无法编译
23.一定要注意if语句里面的代码不要与if语句之外的语句在一个竖列，特别是printf，要注意将属于不同语句里面的printf分离开
     else与if一样，都默认只能控制一个语句【54】
      一个语句的概念是：如果这个语句是一定会执行的，那么他就是一个语句，比如if..else就是一个语句（不是两个语句，因为他们两不是一定都会执行）
24.计算机识别44>s>16这种范围很容易出错（解释去看55），如果要表示范围的话，要用且（&&）和或（||）这种逻辑运算符(44>s&&s>16) 
     多个else if是可以存在的【55】
25.互换两个数字的时候，要使用中间变量      比如互换ij，则定义一个中间变量t     t = i,   i = j,    j = t   【58】
26.本次编程的排序采用了冒泡法，就是abc三个数值从大到小排序的话，分别将每个数值与后面的每个数值进行比较
     比如有abcdef六个变量，先比较ab，ac，ad，ae，af，再比较bc,bd,be,bf,再比较cd,ce,cf,再比较de,df,再比较ef 【59】
27.if else语句如果最后不使用else，语法上不存在错误，但逻辑上是错的，因为问题没有考虑全面，有可能输入值不在上面任何一种情况
     注意，最后一个else的后面不用加括号，他已经默认是除了上面条件的其他所有情况（有if后面才用加括号）
     else（x<0）                                 这样写是错误的，因为else单独就是一个条件语句，这就意味着（x<0）和printf是一个语句里面的
      printf("aaaa\n") ；                          但很明显（x<0）printf这样的东西不是一个语句，是没有意义的，这样写会报错
      但假如你在（x<0）后面加了分号，就意味着else（x<0）；是一个语句，printf("aaaa\n")；是一个语句，就变成了两个语句
      那么情况就变成了：如果要输入值属于else的情况，那么就会执行（x<0）的空语句（没有实际意义），而printf不属于else控制，则一定会输出
28.	for(i=1; i<=5; ++i)                         将i=1命名为编号1，i<=5为编号2，++i为编号3，p=p+i为编号4
		sum=sum+i;                    执行顺序为1 243 243 243 243，注意，在编号2成立的前提下才会继续执行243这样下去【67】
29.解释一下。++i和i++本质上是有区别的，只是在for循环里面没有区别而已,当运用到赋值上面去的时候就有区别了
     ++i，先加后赋值，如x=++i，i=1，那么i就先加加1等于2，然后再赋给x，最终x=2 
      i++，先赋值后加，x=i++，i=1，那么i先赋值给x，x=1，然后i再加一为2，如果还要将i继续赋值给其他变量，那个其他变量才会被赋值为2【67】
30.注意：for循环括号里面是用分号隔开，for循环和if一样，括号后面不用加分号
31.判断for循环里面循环了几次
    方法一，在for循环里面加个printf看输出了几次这个printf（适用于循环次数较少的时候）
                  for(i=1; i<=5; ++i)
                    print发（“aaaa\n”）；
    方法二，直接判断，若是大于等于或小于等于号，循环次数就是限定值-初始值+1.        若是大于小于号，循环次数=限定值-初始值
                 例如for(i=1; i<=5; ++i)就是5-1+1=5次            for(i=1; i<5; ++i)就是5-1=4次
    方法三，for(i=1; i<=5; ++i)   这样就表示每循环一次sum的值就会加一，那么最后sum的值为几，就循环了几次，也就是循环次数对应变量变化次数
                  sum=sum+1              注意要把sum的初始值定为0【69.2】
32.else的后面加分号表示空语句，说明如果不能被三整除的话就执行空语句，也就是什么都不做【69】
     当然这里也可以直接不要这个else，如果不属于if的范围的话计算机是默认什么都不会执行的，只是加上这个else逻辑上会更完整，语法上不会有错误
33.注意要初始化变量，不然计算机会默认为变量的值为1
    for循环里面包括两个语句，一个是if一个是printf ，if语句不一定会再次执行，但是printf一定会随着for的循环再次执行【69.3】
34.最后sum的值一定是一个小数，故用float定义，既然使用float定义的就别忘了用%f输出 【71】
35.sum = sum + 1.0/i;假如说这里没有用1.0而是用1的话，由于i是用int定义的，那么就变成了整形除以整形的格式，这时候计算机是会默认舍去小数位的，
    也就是输入0.5计算机会输出为0，注意计算机也不会给你四舍五入，但如果把1改成了1.0，就相当于1.0是个实数，就变成了实数除以整形的格式，
      此时计算机就会保留小数了，输入0.5计算机就会输出0.5【71】
36.除了将1改成1.0外，还可以使用强制转换实现该程序，格式为sum = sum + 1/（float）（i），也就是给i赋值，然后将i强制转换为浮点数，再进行除法
    先将i赋值，再执行float，再进行除法运算，注意float和强制转化的变量i他们两个的括号不能丢，不能写成（float）（1/i），但可以写成（float）（1）/i
    执行顺序先是右边括号执行，再是左边括号执行，再是其他命令【71】
37.为什么3经过强制转换后会变成3.0：因为计算机将3强制转换为浮点数后要存储他，但是3本身不是浮点数，所以计算机要找一个和3一样的数字存储
     而计算机会认为3.00001或者3.0之类的数和3相等，所以计算机很可能会将浮点数形式的3以3.0的形式存储【71】 
38.有关奇数：如何判断是奇数，对变量用2取余为1      i%2==1
     如何取到奇数，如果用的是i++，那么取到偶数的时候就不能让他执行命令，那么就要使用if语句限制不让偶数执行命令
     当然也可以直接用i+=2让i取值的时候就直接跳过偶数，就不用使用if语句了
39.小技巧，自动规范格式：ctrl+shift+A
     往后挪一大格  选中+tab                往前挪一大格  选中+shift+tab
   %-5d可以方便对齐，-就是左对齐，5就是5个空格，这样每次输出都会空5格
     m = m + 1可以写成m += 1，也可以写出++m
     如果要让a/b能保留小数位，可以写成1.0*a/b，把a变成浮点数，或者写成a.0/b，或者（a+0.0）/b
     除了除法以外，整形变量+-*一个浮点数，其输出结果都会变成的浮点数
     1.0默认是double型的浮点数，不是float型的浮点数
40.  for（1；2；3）               执行顺序1 2 45A65A65 32 B
              for（4；5；6）        把第二个for循环（456A）看成是一个整体m，那么就只剩下第一个for循环了，执行顺序就是12m3
                    A；                     而整体m的内部又是一个for循环，执行顺序是45A6，注意6执行完了要回去执行5，要是5成立第二个for循环就没结束
                    B；                     要再来一次A65，直到5不成立后退出第二个for循环，再执行第一个for循环的3，当3执行完后再执行2看是否成立
若不成立则第一个for循环结束，此时两个for循环都结束，然后执行B（B不属于任何一个循环，两个for循环都只能控制一个语句），然后程序运行结束
若2成立，则要再执行一次第二个for循环，也就是再来一次4 5A6 5A6... 5，当5不成立后再退出第二个for循环，回去执行第一个for循环的3，然后执行2
此后便一直执行第二个for循环，直到第一个for循环的2不成立，第一个for循环结束，此时也不会再执行第二个for循环（第二个for循环镶嵌在第一个里面
，第一个for循环不执行了那么第二个for循环就一定不会执行），然后执行B，程序运行结束
41.运行速度：硬盘<内存条<cpu，i++是直接在cpu里面运行的更快，i+=1是在硬盘运行的比较慢
    注意i++不要单独成一个语句出现，比如要给i赋值时不要利用i++来替代i=i+1，i++就放到循环语句里面用就行
42.顺序点：逗号，括号，分号
43.三目运算符，用于简写if else语句，用？和：表示，比如i=（A?B：C）；等价于if（A）
                                                                                                                执行   B
							否则else 执行  C
44.逗号运算符，执行的一定是最后的那个语句       首先执行k++语句，k的值变为了3，然后执行k+=3的语句，k的值又变成了6，然后执行k+2的语句
    k = 2				        但是注意这里只是单纯的把k加了个2，并没有把k+2的值赋给k，也就是只是产生了个k+2的临时值，
    i = （k++，k+=3，k+2，k-1）                   k的值没有变化 ， 最后执行k-1的语句，k的值最终为5，因此i就被赋予k的值，也就是最终i=5
    如果这里是i=（1，3，5，9），最终i的值应该是9   
45.for和while可以互相转换，具体格式
      for（1；2；3）                 等价于                      1；	             也就是按照for的顺序执行12A3的顺序，先再while执行前定义一下变量，执行1语句
      A；                                       ===    		while（2）             然后执行2的条件语句，使用while判断2条件是否成立，如果成立，则执行A语句，
     					{	          然后执行3语句，最后回去判断2是否成立，注意while一定要加上大括号控制两个语句
					    A；        在清楚for语句的执行顺序时，很明显for语句比while更好用，他的代码更简洁，而且不容易
					    3；      乱，他的对象和条件都写在一起了，整体思路会更清晰，但如果是你对象还不够明确，思路还
					}             不够清晰的时候，使用while语句更有利于你思路的推进
46.如何看懂一个程序：1.分析流程，看懂这个程序有几个语句
		   2.分析语句，看懂每个语句是怎么运行的
 		    3.试数，随便输入一个数，把自己当作计算机，一个一个语句执行，看最后结果是什么
47.在for和while的语句里面，编号二的限定值不一定使用具体的数字，比如
     for（i=1，i<6, i++）    ==>    也可以写成  	scanf（“n=%d”， &n）；           6那个具体数字可以改成一个变量，变量的值可以
					for（i=1，i<n, i++）                      由我们自己输入
48.while(m)            	计算机判断0为假，其余为真，也就是说，只要m的值不为0，就可以执行while语句   【实战1】
49.总结：利用取余把个位数给提出来，然后利用乘10将提出来的个位数放到比较值的十位上去，然后利用整数除以整数的特性将输入值缩短，
	将原来输入值的十位挪到个位上去，继续提出输入值的个位数，利用加法将这个提出来的数放到比较值的个位上去    【实战1】
     	while(m)  //计算机判断0为假，其余为真，也就是说，只要m的值不为0，就可以执行while语句 
	{
		sum = sum * 10 + m%10; //sum*10是为了把之前提出的个位数放到十位数上，m%10取余是为了提出个位数 
		m/=10;  //删掉个位数 
	} 
50.之所以第13行，第15行写成1 == n而不写成n == 1，是因为我们写程序时常常会写成n=1，忘记写两个等于号   【实战2】
       而如果写出n=1的话计算机是不会报错的，但是这样写很明显是偏离了程序目的的，但是如果你写成1=n的话程序就会报错，避免了事后找错找半天
51.思路：将f1，f2（第一第二项）相加得第三项，再将第二第三项的值赋到f1，f2上，再将f1，f2（第二第三项）相加得第四项 
     当for的循环次数需要由我们自己控制的时候，记得定义一个中间变量来配合我们自己可以改变的那个变量，这样才能控制循环次数 
     for循环的固定循环次数可以有很多种写法  for（i=1;i<=n;i++）  ==   for(i=n;i>=1;i++)   这两种写法都是n越大循环次数越多        【实战2】
     for(i = 3; i<=n; i++)
		{
			fn = f1 +f2;
			f1 = f2;
			f2 = fn;
		}
-------------------------------------------------------------------------------------------------------------------------------------------------------
52.do....while 的格式
    do                                    就是当while后面的条件成立的时候，把do下面那个大括号包括的语句从头到尾再执行一次
   {                                          这个执行是没有限定次数的，也就是说只要while后面的条件还成立，大括号里面的语句就会一直重复执行下去
       ................                       注意这里大括号里面的内容是一定会执行一次的，然后才去判断while是否成立是否要再次执行的
   }while（...........）;		  格式要注意：do后面一定要有大括号，while后面一定要有分号  【一元二次方程升级版】
53.当用char定义字符时，输出用%c，注意前面要加上空格，即printf（“ %c”）,引号内的%c前面要有个空格        【一元二次方程升级版】
    因为输入回车时计算机会把回车这个操作留在缓冲区，计算机就会默认你打的那个回车是赋给那个变量的，在输入前打个空格可以抵消这个作用    
54.这里的break有终止运行的意思，也就是只允许运行break上面的语句 
    这里的case可以理解为程序的入口，符合case的哪种情况，就从哪里开始执行程序，遇到break才停止，否则继续执行下去
    注意一下格式问题，每个case的后面都要加上冒号，且每个case里面要记得加上break命令
    注意break后面不要忘记加分号，最后一个default后面也要加上冒号    【90】
55.注意这里的精髓是第16行的强制转换，由于输入的成绩可能会有小数，所以强制转换为整形
     后再利用整形除以整形只保留整数位的特性来分类讨论    【实战3】
56.if语句如果要用switch替代的话会比较麻烦，所以一般写程序的时候尽量少用switch
    因为if语句可以表示范围，但switch里面的case后面只能跟一个常数，所以必须要用到强制转换和整形除以整形的特性减少范围内的数字情况
    然后列举多个case来表示范围【实战3】
57.break用来终止switch的执行，也可以用来终止循环的进行，但不能用来终止if的执行
    有多个循环语句时，break终止离他最近的循环
    当if是循环内部的一个子句的时候，可以出现break，但这个break也是用来终止循环的
----------------------------------------------------------------------------------
    for（。。。）     这里的break就是用来终止for循环的，不是用来终止if的
      {  if（。。。）            所以这里的printf根本就不会输出，因为还没轮到他执行就已经执行了break了，for循环就会马上结束（前提是if成立）
        break；
        printf（“”）}
---------------------------------------------------------------------
 switch（。。）				
      case 1：			这里的break是用来终止离他最近的switch的，也就是第三行的那个switch
      	switch（。。。）                     那么第一个switch的case2仍然是会执行的，因为第一个switch的case1里面没有终止第一个switch的case1的break
                	case 1：		只有终止第二个switch的case1的break
 		break；		所以写程序时一定要注意，有几个循环几个switch，就要有几个break，不然程序很容易出错
      case 2：
----------------------------------------------------------------------------
for（1，2，3）
{			这里的continue执行完后会执行3，然后再判断2是否成立
      A；             	             continue结束的是大括号里面的语句，不会终止循环
      continue；             
}
58.注意你敲完12asd时是敲了一下回车的 ，第10行的!= '\n'就是当出现换行符（回车）的时候while语句删除【41，93】
     while( (p = getchar())  != '\n' )   解释一下这个语句，p = getchar()就是当p获得一个字符的时候，char后面那个括号表示的就是获得的具体字符是什么
     也就是相当于printf之类的语句后面也要加括号一样，就是一个格式问题，这种需要被赋予具体值的非变量都要加括号，由于这是一个完整的语句，所以
    p = getchar()的外面也要加一个括号，防止计算机读错这个语句了，！是非的意思，！=就是不是的意思\n就是换行符，那么连起来就是：不是换行符
   那么把整句话串起来，就是当p获得字符，且这个字符不是换行符的时候，执行while循环语句
59.continue的作用，用于跳过本次循环大括号中余下的语句，转去判断是否需要执行下一次循环
     continue和while语句连用，可用于清除无用输入值   【41.93】
     continue也可以和if语句连用，用来判断是否跳过剩下的语句
60.注意一下break和continue的区别，continue是跳过剩下的语句，不会终止循环，而break会终止循环，但相同的是他们的作用对象都是循环语句
     即break只会终止循环，而continue也只会跳过循环剩下的语句
  比如 for（1，2，3）  					for（1，2，3）  
              { continue；      这里就是跳过B语句执行3，然后再判断2                 {  break；         这里的break就是终止循环，当执行完break的时候
               B；}               如果2成立继续循环，continue没有终止循环                  B； }         循环终止，整个for循环不会再运行
61.while（。。。）  while也是一个循环，当括号里的东西成立之后执行A,然后又会跳回去判断括号里的东西是否成立，是否要再次循环
         A；                     一定不要忘了while也是个循环，要跳回去再次判断是否要继续循环的
62.这里一定要注意continue跳过的是循环的那个大括号里面的语句，也就是当do while里面包括if时，跳过的是do while循环的那个大括号，
    不是if的大括号。    【96】
63.创建数组赋值的时候要用大括号                           【98】
     要注意的是[]里面的数字是表示创建了几个数组，不是最后一个数组的编号是多少，也就是a[5]是创建了5个数组，不是最后一个数组的编号是a[5]
     数组的编号是从0开始编号的，也就是第一个数组是a[0],最后一个数组的编号是a[4] 
64.一维数组的特点
                 1.为n个变量连续分配存储空间
	 2.所有变量的数据类型必须相同
	 3.所有变量所占的字节大小必须相等
65.一维数组相当于是一条线，而二维数组相当于是一个面
66.一维数组的初始化
                1.完全初始化     int a[5]= {1, 2, 3, 4, 5} ;         就是定义的所有数组内的元素都给赋了值
	2.不完全初始化   int a[5] = {1, 2, 3};         就是只有定义的部分数组给赋了值，剩下未被赋值的数组元素默认被赋值为0
	3.不初始化       int a[5];     只有定义没有赋值，这时数组内的所有元素都会被随机赋予一个垃圾值
	4.初始化清零   int a[5] = {0};           就是把数组内的所有元素都给赋值为0
67.一维数组易出现的错误写法
      int a[5];                          不可以先定义再赋值，只有在定义的时候赋值才可以给每个元素都赋到值，先定义在赋值只能给某一个元素赋值
      a[5] = {1, 2, 3, 4, 5} ;      第一行的a[5]是创建5个元素，而第二行的a[5]是变量名称，就是一个变量的名字就是a[5]，不能给到a[2]等元素赋值

     int a[5]= {1, 2, 3, 4, 5} ;    名称=个/行/列-1，这里创建了五个数组，那么最后一个元素的命名应该是a[4]
     a[5] = 100;		所以根本就没有a[5]这个名称的元素，因此第二行的命名就是无效的
68. int a[5] = {1, 2, 3, 4, 5} ;
      int b[5];
    如果要把a数组中的所有元素的值都赋给b数组
   错误写法         a[5] = b[5];        只有在定义的时候a[5]才能表示数组中的五个元素，其他语句中都是表示一个变量的名称，或者说是数组中的其中一个元素
   正确写法   for（i = 0；i<5; i++）    遇到交换数字之类的程序，别忘记for  +  bi  +  i++这类好用的组合，比如交换b1和b4，b2和b3
                         b[i] = a [i];               就可以使用for循环+ b[i]+b[j]+ i++ + j--
69.概念理解 
     注意定义时的a[5]是表示数组内的五个元素，但后面写语句是如果出现a[5]就是一个变量的名字叫a[5]了，不表示数组内的5个元素，参考67条笔记第一个
    不完全初始化是定义的时候没赋完值，不是后面用scanf给数组元素赋值时没赋完，没被scanf赋值的元素算是未初始化，会是垃圾值，不是不完全初始化
70.小技巧
      将1与7换，2与6换，保证对称的这样换就可以将数字倒过来，交换时注意利用两个变量ik，17交换完后一个加一，一个减一就可以继续将26交换 
     需要输出多个变量时，利用for循环，这样就不用连续打7次printf了
     时要输出多个变量的时候，也尽量写成a1a2这样，不要写成abcd，这样就可以利用for循环更方便输出a1a2      【101】
71. 命名+1就是行数，列数或者个数
    二维数组定义 int a[3][4];      二位数组是一个面，默认[3][4]表示的是3行4列，不是3列4行，总共12个元素
     命名时，行>列，即先排第一行的1234列，再排第二行的1234列，再排第三行的1234列
     就是a[0][0],a[0][1],a[0][2],a[0][3],a[1][0],a[1][1],      注意同样的a[3][4]也是不存在的，只能到a[2][3]
72.二维数组的赋值 
        1，  int[2][3] = {1, 2, 3, 4, 5, 6};             大括号后面别忘记分号
        2.     int[2][3] = {
                           {1, 2, 3},                    注意格式：外面两个大括号一定要单独成行，中间的两个大括号中间一定要加上逗号
	          {4, 5, 6},                   这样写可以把第1第2行的每个数字直观的显现出来，不用再从头到尾重新数一遍
                              }；
73.二维数组的输出：用两个for循环
             for(i=0; i<2; i++)                                 
             {
                      for(k=0;k<3; k++)
                            printf("%d   ", a[i][k]);
                      printf("\n");
             }
74.多维数组是不存在的，多维数组其实就是二维数组的叠加
    比如a[3][4][5],其实就是a[3][4][0]，a[3][4][1]，a[3][4][2].。。。也就是把[3][4]看成一个整体[p],那么他就是a[p][5]的二维数组
75.函数的作用就是一个工具，可以避免多次使用重复代码
     函数调用完每次都会释放内存，在int main（void）语句中可以调用函数，函数写在int main（void）的上面  【105】
76.为什么需要函数：避免了重复性操作，有利于程序的模块化
    什么叫函数：逻辑上-能够完成特定功能的独立的代码块‘
	        物理上-能够接收数据并对其进行处理，能将数据处理的结果返回
    函数的名字是自己定义的，功能也可以自己定义，不是软件给你写好的，固定的   【105】
77.void fas(void)     括号里的void表示函数不能接收数据，即下面调用函数的时候只能写成j=fas（），即对j使用fas函数
		不能写成j=fas（a，b），即不能让fas函数先接收ab的数据，将ab使用于fas函数后再将fas函数用于j
                                最前面的void表示该函数不能有返回值，就是在编写这个函数功能的时候不能加上return 0之类的东西
                                 如果有返回值，就会让main函数重新执行一次，如果没有返回值，就会在你调用完这个函数后继续运行下一行代码 【105】
78.函数的定义
            函数的返回值   函数的名字  （函数的形参列表）
                {
		函数的执行体
	}
        函数的返回值就是函数最后的return后面的那个数是以什么形式返回的，比如说int main（void）就是函数最后是以整形int返回的
        又比如void fas（void），就是函数最后是空返回的（void是空的意思），也就是函数最后返回了个空，也就是函数不会有返回值
         也就是函数中不能出现return 0之类的（但可以出现return，就是return的后面不能有数字），函数执行的结果也不能返回到主函数去
       返回值是决定自定义函数的东西能不能到主函数中去的，形参是决定主函数中的东西能不能到自定义函数中去的     【115】 
        自定义函数到主函数中的东西在return后面，主函数到自定义函数中的东西在main函数调用该函数的括号里面fas（。。）
注意点1：当return后面的数字类型和返回值不一致的时候，以返回值为主，
    比如  int main（void）         显然，函数的返回值是int整形类型的，但最后的return后面是个10.5（浮点型），前后不一致
                  return 10.5；      这时就应该以返回值为主，也就是最后应当是整形，那么最后程序就会以10返回而不会以10.5返回
注意点2：形参分为有参和无参，无参就是fas（void），这时候使用该函数就只能直接使用该函数执行体，不能使用到main函数中的其他变量数据
                有参就是括号内要定义参数，也就是fas（int a），这时候调用该函数就可以使用到main里面的变量数据来代到这个函数中去
79. return是终止函数的，break是终止循环或者switch的
     如果return后面有值，则终止函数并返还这个值给主函数（一般是返回给main函数）（前提是他可以有返回值，即函数名前面不能有void）
    void fas（void）
            for（i=0；i<5；i++）			这里的break是终止for循环的，这里的return是终止fas函数的
                       {break；
                       return；}
80.函数的分类
    一：有参函数和无参函数，    void fas（int i） /     void fas（void）
    二：有返回值函数和无返回值函数      int fas（void）   /    void fas（void）
    三：库函数和用户自定函数     printf（“。。。”）    /     void fas（int i）
    四：值传递函数和地址传递函数（指针）
    五：普通函数和主函数         int fas（void）   /     int main（void）
    
     主函数可以调用普通函数，普通函数不可以调用主函数
     普通函数之间可以相互调用，普通函数也可以调用自己（递归函数）
     一个程序必须要有主函数，且只能有一个主函数（main）
    主函数是程序的入口，也是程序的出口
81.如果一个函数的执行结果不是a就是b，那么输出时就应该直接让那个函数让他在printf中执行，不能先执行再输出，应该输出的是它的执行结果
        也就是   max（a，b）     这时候不管你printf里面逗号后面是a还是b，都不可能包括所有的可能性，因为max函数的执行结果可能是a也可能是b
                   printf（“。”，）           如果你写了a，但max执行结果是b，便会出错，如果你写了b，但max执行结果是a，那么会出错
         这时候应该写成  printf("%d",max(a,b))    应该记住目的，我们的目的是输出max函数的输出结果，而不是将a或b的值输出，
   ab都是max函数的执行结果，我们只要输出了执行结果，那么不管执行结果是a还是b，都可以将他输出
         函数里面具体是直接用printf直接输出，还是使用return把执行结果交还给主函数处理，是根据你写函数的目的来决定的   【105】
82.bool函数的特点就是他的执行结果只有true和false，也就是只能为真或者假 
     if就是判断真假，这个bool函数的执行结果只有true和false，如果是if（ture）就会执行，如果是if（false）就不会执行
83. 这里判断素数的方法就是让他与2到输入值的数字相除，如果能被其中的某个数字除尽，那么他就不是素数      【111】
     因为素数除了能被1整除外，不能被其他比他小的数字整除，因此，只要那个数字不被比他小的任何一个数字整除，他就是素数 
    举个例子，比如9，那么2-9之间的数字有8个，要用9分别除这八个数字，即9/2，9/3，9/4，9/5.... 
     可以看到，当9/3的时候就已经被整除了，那么9就不是素数 
    但这个时候还不能马上判断，因为for循环中的那个数字最后是一定会被整除的，而整除他的那个数字 
    可能是一个比他小的数字，也可能是他本身，比如5最后就是被自己本身整除的，比如9就是半路被3整除的 
     因此最后第13行要加个if语句加以判断，如果是被自己本身整除的话，那么for循环就已经运行到最后了 
     由于是val/i，如果是被自己整除的话那么val一定是等于i的，因此如果被自己整除（即i=val），就是个素数，反之则不是     【111】
84.当定义函数的时候，函数名后面的括号是直接使用主函数中的变量还是自己定义个中间变量的问题  
    结论：当主函数中的变量是由用户使用scanf输入的时候，直接使用主函数变量，当主函数中的变量是定义直接赋值的时候，需要定义中间变量
    原因：当变量是直接定义赋值的时候，由于函数是通用的，他还要使用到别的变量上去，所以如果你写成 bool sushu（int val），
    那么主函数中的其他变量就无法使用这个函数，因为这个函数只对val这一个变量有效，但如果你写成 bool sushu（int i），那么其他变量要使用这个函数
    只需要写sushu（a），即让a执行sushu这个函数
    当变量是由scanf输入的时候，这个变量本身就可以是任何数字了，函数只需要对一个变量有效就行    【111】
85.自定义函数和主函数可以出现一样的变量，因为是在两个函数里面，变量之间互不干扰，两个函数之间的桥梁只有return
    比如你自定义一个fas函数，int fas（int i），后面在main函数里面也可以有个int i，这两个函数里面的i是不一样的
86.假如一个函数是int fas（int i），这时候在主函数中写道int i            
                              return 10			        i=fas（6）
      就相当于是将6赋给fas函数中的i，然后fas函数返回一个10给主函数，这时候主函数的i收到的返回值就是10
         因此fas函数中的i=6，主函数中的i=10
87.计算机读代码的时候从上往下解析，但从main函数开始执行
      一定要搞清楚执行顺序，一个先执行的函数中出现了后执行的函数的名字，就要对后执行的函数进行声明 【113】
88.注意的点1：函数的声明一定要保证返回值和形参要一样，也就是第三行和第十行要一样，不能第三行 void fas(void) 第10行就int fas（void）
    第三行要配合第十行写，因为第十行的才是主函数，第三行只是声明
    注意的点2：函数的声明一定要在后面加上分号，但定义函数的时候不要加上分号     【113】
89.形参和实参：形参就是变量，实参就是变量被赋予的值
     关系：形参与实参是一一对应的关系，他们的数量必须一致，位置也必须一致
     void fas（int i， float k）假如定义了一个这样的函数，那么后面调用该函数的时候就要写成fas（5，6.6）不能将5和6.6倒过来
     因为定义函数的时候是先定义一个整形形参，再定义一个浮点型形参的，所以后面赋值的时候也要写赋予整形实参，再赋予浮点型实参
     这里的i，k就是形参，i和k所赋予的值就叫做实参
90.常用的系统函数，不用在主函数前面注释，可直接调用
    double sqrt(double x)    --   求x的平方根
     int abs(int x)                  --     求x（整型）的绝对值
    double fabs(double x)    --     求x（浮点型）的绝对值
91.栈：就相当于一个杯子，一个箱子
      压栈：就是入栈，就是把函数所需要的空间压进去，给他分配空间
      出栈：就是把给函数分配的空间释放掉
     记住，先入栈的函数会后出栈（先入后出），可以理解为先入栈的函数给后入栈的函数压住了动不了，要等后入栈的函数出去了才能出去
92.函数不能重复定义，也就是int fas（int i）	这样就会报错，因为你形参已经定义了一个i了，执行体再定义一次就会出错 
			{ int i；}
93.变量的作用域和存储
   按作用域分：全局变量，在函数外部定义的变量，就是不写在函数里面定义的变量，比如写在include和main函数之间的int i
                                       全局变量只能在定义他的下面可以使用，比如你先写了个函数用了全局变量i，但是你的全局变量i是在这个函数后面定义的
		       那这样就会报错，因为你先使用变量再定义变量逻辑上是有问题的。
	        局部变量：就是在函数内部定义的变量，只能在这个函数里面使用，比如写在main函数里面的int i
                     全局变量和局部变量冲突的问题：如果你定义了一个全局变量i，但你定义局部变量的时候也定义了一个i，这时候就会出现输出i的时候
                                                                       是输出全局变量的i还是局部变量的i的问题，这个问题视软件不同会有不同，有些软件是输出局部
				     有些软件会输出全局，也有些会报错
    按变量的存储方式 ：静态变量，动态变量，自动变量，寄存器变量（寄存器就是内存条之类存储数据的）   
94.指针就是地址，加*就是存放地址的变量，他只能用来存放同类型变量的地址
        如int *p就代表p是用来存放int类型地址的变量，他不能存放变量，是存放地址的，
        如果i=3，就说明i是一个整型变量，这时候p=&i就是对的，因为p存放的是同类型变量的地址，&i就表示i的地址，所以就是把i的地址保存在p上
    这时候就说明了p是一个指针，他可以指向i，也就是p保存了i的地址，可以通过p找到i
    虽然p指向i，但是两者互不影响       。      普通变量存储的是值，指针变量存储的是地址
        如果一个指针变量指向了某个普通变量，那么    *指针变量 == 普通变量，也就是  *p就不在是一个指针变量了，这个整体就相当于是一个普通变量i
        比如 *p是一个指针变量，并且存放了普通变量i的地址，那么p就指向了普通变量i ，这时候*p完全等价于i
    或者说：在所有出现*p的地方都可以替换为i，在所有出现i的地方都可以替换为p
    注意：int*是一个整体，p是另一个整体，*p不是一个整体，*是有一个指示的作用，int*是变量类型，p是变量名字
	int*类型就是存放int变量地址的类型   
    *p就是以p的内容为地址的变量，比如p为指针变量，他的内容就是存放的i的地址，那么*p的地址就是i的地址，那么*p就是i，因为两者的地址相同
     地址就是内存单元的编号，编码是0101这类数字的总称，是具体数字，而地址只是一个区域。
    指针就是地址，他就是一个值，指针变量是存储指针（地址）的变量，指针不等于指针变量
95.指针的重要性：表示一些复杂的数据结构，快速传输数据，使函数返回一个以上的值，能直接访问硬件，能够方便的处理字符串，
	            是理解面向对象语言中引用的基础
     指针的分类：基本类型指针，指针和数组，指针和函数，指针和结构体，多级指针
96.地址的定义：内存单元的编号，从零开始的非负整数
97.cpu与内存条的三条线：控制线，数据线，地址线
    控制线：控制数据的传出和传入
    数据线：用来传输数据
    地址线：用来确认读取内存条上哪个单元的数据
98.地址线一般电脑有32位和64位之分，一条线控制01两个单元，32位就是有2的32次方个单元，一个单元是8位 （单元就是字节）8位就是8个0或1
     1K（K就是KB）=2^10B(B是位)，1M=2^10KB=2^20B,1G=2^10M=2^30B,那么2^32B=4G
     地址的范围（0~4G-1），包加不包减，因为是从零开始的，所以0和最后一位都要算上，那么如果最后范围是4G的话，就有4G-0+1=4G+1>4G
     显然不能大于4G,所以最后一位应该是4G-1，这样范围内才是4G-1-0+1=4G刚好是4G内存大小，这就是范围内的最大值
99.指针的本质是一个操作受限的非负整数，他的本质就是编号，指针直接不能+*/，但可以减，减的具体意义就是看不同地址之间的差距是多少格
100.int *p，int i=5，*p=i，这样写是错的
       *p是以p的内容为地址的变量，*p是指针，由于没有写p=&i，所以i的地址没有保存到p中，那么*p就会随机指向一个垃圾值
       那么*p的地址就是那个垃圾值的地址，那么*p就等于那个垃圾值，那么*p=i就相当于把i的内容赋给*p，也就是把i的值赋给那个垃圾值，
     那么那个垃圾值就会被i的值替换掉
101.如果写了int*p，int *k，那么*k=p就是错的，因为*k是以k的内容为地址的变量，他的类型是int类型，而p是int*类型，他们两者的数据类型不一样
       就不能将p的内容赋给*k
102.解释int *p的含义，首先p没有给赋值，它本身就是一个垃圾值，*p则是指p所指向的地址，而p虽然没有被赋予程序本身定义的变量地址（p=&i之类的）
       但是p实际上是有指向的，他指向的是一个垃圾值的地址，这个垃圾值是上一个程序遗留下来的，那么*p实际上就是读取上一个程序遗留下来的垃圾值
       的地址，但显然，这个地址不属于本程序，他的内存已经在上个程序运行完的时候释放掉了，那么*p就无法读取这个地址

 注意：int *p实际上就是定义了一个p变量，*的作用是告诉计算机这个变量p是一个指针变量，因此p是一个变量，*p是p所指向的变量，他们都是变量
       p是int*类型的，*p是int类型的，区别是p是属于本程序的变量，他是本程序定义的变量，会在内存条上分配到空间，本程序也可以直接读取他
       而*p是p所指向的变量，而p所指向的变量不一定是本程序的，比如p=&i，那么就相当于是p指向了一个本程序的变量i，那么*p也就是本程序的变量了
       系统就可以直接读取*p了，p指向i，那么*p就是i，那么系统读取*p的值其实就是i的值，但是如果没有写p=&i，p就变成了一个野指针，
       由于定义的时候就已经说了p是个指针了那么p就一定会有一个指向，这时候p就会随机指向一个垃圾值，这个垃圾值是上一个程序留下的，
       也就是p所指向的变量不是这个程序的变量，他所指向的是上一个程序的变量，那么程序就无法读取*p，*p装的是上一个程序的东西，
       本程序无法读取上一个程序的东西
103.函数调用时的执行过程语句：就是把主函数调用时括号内的内容赋给自定义函数中的变量，注意括号内的内容和自定义函数变量两者的数据类型要一致
       比如void fas（int a）  就是把第三行括号内的p赋给第一行括号内的a，写成代码就是相当于
             int main（void）   fas（p）的语句就相当于执行了 a=p的语句，
               fas（p）              注意：是将p赋给a，不要搞反了              注意：p与a的数据类型要一致，定义时就要注意（除非是指针变量）

      同样 void fas（int *a）    同样就相当于fas（&p）的语句就相当于执行了a=&p的语句
              int main （void）   一定要注意第三行括号内的内容是赋给第一行括号内的变量，即赋给的是a不是*a
              fas（&p）               这样就把两个函数通过指针变量a指向p联系了起来 （别忘记加上&）
104.指针的优点，在于可以跨函数改变变量，比如自定义函数里面的指针p指向了主函数的a，自定义函数看i的指针k指向了主函数的b，
        那么就相当于*p=a，*k=b， 那么在自定义函数里面改变*p和*k，同时也会改变主函数里面的ab，二者是同步改变的
        注意是改变*p和*k，不是改变p和k，改变pk只是改变了自定义函数，不会影响到main函数里面的ab变量
        注意用指针跨函数交换数字的时候，交换三连定义的中间变量不要写成了指针类型
              *p和*k是int类型的，p和k是int*类型的，由于要交换ab，所以这里要改变的是*p和*k，所以t要定义为同类型的int类型，不能写成int*t 
通过指针可以联系起两个函数的变量，可以做到其中一个函数中的变量与另一个函数中的变量同步改变，其灵魂就是*p=k的语句是可以跨函数使用的
只要是同一个程序内的，即使是不同函数也可以通过指针联系起来，这样*p的改变就会影响到k的改变    【127】
105.一定要注意 int *p中，p是一个变量，*p也是一个变量
       但是p存放的是地址，他不能存放具体的值。     *p存放的是p存放的地址的内容，存放的是具体的值
       而且p存放的地址数据类型还要一样，如果你定义char ch，int*p，就不能写p=&ch，因为*p是整型，而ch是浮点型
106.一维数组名是一个指针常量，他存放的是第一个元素的地址（注意存放的是地址不是数值，a不等于a[0]）
       注意：a是一个常量，是一个指针常量，存放的是地址，不是数值，它也不是变量，他的值不能改变
      也就是说比如a[5],里面a就是该数组的名字，他存放的是第一个元素a[0]的地址，也就是输出a和输出&a[0]的结果都是一样的，都是第一个元素的地址
      具体通过代码表示可以写成p[i]=*(p+i)=a[i]，也就是数组的下标具体表示成指针变量的话就是这么写
      比如你写一个数组int p[3],那么如果有个指针变量k指向p，那么*k就表示p的内容也就是p[0],*k+1就是p[1],*k+2就是p[2]
107.指针和指针之间也是可以互相指向的，比如int a[5],里面的a实际上就是一个指针常量，因为a存放的是第一个元素的地址，所以他也是一个指针
      这时候定义一个int *p，那么是可以写p=a的，这样p指针就指向a了，则此时   *p=a[0],    *p+1=a[1],   *p+2=a[2]
     同样的，两个指针变量pq，如果p指向q，实际上就相当于复制粘贴了一个q，pq在各方面都是一样的，他们存放的内容也是一样的，也就是说此时pq
     就不是谁指向谁的关系，p就完全等于q，p指向哪个变量，q就指向哪个变量，也就是改变了p所指向的变量，就相当于改变了q所指向的变量    【142】
108.确认一个数组的信息，需要两个参数，一个是指针变量，用于连接数组，一个为一般变量，用于确认数组的末尾元素
       注意:连接了数组就连接了首个元素，因为数组名就对应了首个元素；确认了末尾元素就确认了循环次数，确保刚好能输出完数组的所有元素

       这里的指针p是用来连接数组的，利用*p输出a[0],利用*(p+1)输出a[1],利用*（p+2）输出a[2] 
      for (i=0; i<e; i++)                   //a5的话只能写到p+4，i最大是4，那么i<5，a6的话只能写到p+5，那么i最大是5，那么i<6 
	printf("%d   ", *(p+i));   //不难发现，a后面括号内的数字是几，i就小于几，所以直接将a后面括号内的数赋给用来确认数组末尾元素的变量e 
      printf("\n");		     //然后用e来确定循环次数，确保将数组内的所有元素刚好输出 

     当指针指向的是一个数组的时候，那个数组名称前面不用加上取地址符，比如这里指针p要指向数组a，直接写成p=a即可，不用写成p=&a     【134】
109.对于一个指向数组的指针变量p，若出现p[3]=88的代码，其意思就是*（p+3）=88，也就是其指向的那个数组里面的第四个元素的值变为了88
       如果那个数组叫a，由于p指向a，那么*p=a，由于a指向a[0]，那么a指针常量的内容是 a[0],那么*p=a[0],那么p[0]=*p=a[0],那么同理p[3]=*p+3=a[3],
      一定要记住，如果指针p指向数组a，那么p几=*p加几=a几
110.两个指针必须要指向同一空间的两个存储单元才可以相减，比较常见的是数组，因为数组的存储空间是一整块的，不是分散的
       当pq指针都指向a数组的时候，p指向a0，q指向a4，这时候pq相减就有意义了，表示的是这两个指针指向的地址相差多少个单元
111.指针指向什么类型的变量，就占多少字节，比如指针p指向char类型，就占一个字节，若指向int类型，就占4个字节
      判断某数据类型所占的字节数，用sizeof语法，比如int *i，sizeof（i）=4，char *ch，sizeof（ch）=1
      int是4字节的意思是：int类型的变量占4字节，不是int本身4字节，是变量是4字节，无论那个变量的值是多少都是4字节
      结论:无论一个指针变量指向的是什么类型的变量，这个指针变量本身所占的字节大小都是4字节
      原理：一个指针变量所指向的那个普通变量，无论那个普通变量是什么类型，该指针都是保留那个变量的第一个字节的地址，比如int类型
      有4字节，但指针只保留第一个字节的地址，而第一个字节的地址是一串数字，这一串数字刚好是4字节，因为这一串数字是cpu与内存条那32根线决定的，
      32根线就是32位，32位就是4字节，所以一个指针变量本身就占4字节      
      注意：不一定什么时候都是4字节，主要看你电脑的操作系统是多少位的，还有你的编程软件支持多少位的，比如你32位的电脑用32位的软件就是32根线
                你64位的电脑用32位的软件还是32根线
112.传统数组（静态数组）的缺点：
       数组长度必须事先制定，且只能是常整数，不能是变量，比如int a[b]就是错的，括号内不能是个变量，int a[2.5]也是错的，括号内得是整数
       数组不能自动释放内存，不能说运行完这个数组代码就释放他的内存，必须等函数运行完毕才会释放，也就是该数组内存不能由程序员手动释放
       数组的长度不能在函数运行的过程中动态的扩充或缩小，也就是其长度确认后就无法改变了
       a函数中定义的数组，在a函数终止运行之后就无法再使用a函数中的数组了（因为该函数运行完内存就被释放了） 
113.如何定义动态内存及其语法
       int *p = （int*）malloc（4）
       这里的malloc（4）就是向系统申请了4个字节的内存空间，这4个字节的内存里面存放了准备给p的地址（也就是p会指向malloc申请的内存），
       但申请之后只会返回第一个字节的地址，这样的话指针p就无法知道完整的地址，因为只有第一个字节，这时候在前面加上（int*），意思就是强制转换，
        也就是将第一个字节强制转换位int*类型，这样指针p就知道要读取从第一个字节开始的后面3个字节作为p要接收的地址，
       注意:由于p是指针变量，所以强制转换的时候也要转换为指针类型
      注意：使用malloc一定要在上面写上#include<malloc.h>
      注意：malloc的形参就只有一个，也就是只能向系统申请一次内存，比如这里就向系统申请了4字节内存给形参来存放地址，然后再把地址给p
 注意：malloc申请完内存后的返回值是第一个字节的地址，所以接收这一块内存的变量也要是个指针变量，强制转换时也是把那一个字节强制转换为指针类型 

       这一行代码占了8字节，因为malloc向系统拿了4字节空间放地址，而p指针本身又占了4字节，也就是malloc申请的4字节+p指针本身的4字节=8字节
       但p指针本身所占的4字节是静态内存，而p所指向的内存，也就是malloc申请的那4字节是动态的
       
       free(p)   意思就是把p指向的内存释放了，也就是释放了动态内存（释放malloc申请的内存），
                     但p本身的内存不会释放，因为p本身的内存是静态的，只会随着函数终止而释放。
     
当用malloc定义了一个动态形参的时候，后面就可以写*p=5之类的了, 这里的*p就是指malloc的形参, 这个形参就是动态变量，这个形参的内存就是动态内存
114.如果是在自定义函数中定义的动态内存，在自定义函数运行完后该段内存也会存在，那么在主函数中仍可对这块内存进行更改

      注意释放内存的时候一定要写成free（k），free后面括号里的必须是个指针变量，意思是释放这个指针变量所指向的内存，不能写成 free（*k），因为
      *k不是一个指针变量，k才是一个指针变量
      也不要写成free（p），即使p和k是拷贝的关系完全相等，因为p是main函数里面定义的变量，不属于fas函数，而且p也是一个局部变量，
      不能在fas函数里面使用      
                                 
      int *p = (int *)malloc(sizeof(int));  //这里的sizeof(int)就表示int类型所占的字节大小，所以sizeof(int)=4，也就是malloc(sizeof(int))=malloc（4）
      也就是p指向了一个拥有4字节大小的动态内存空间                【142】
115.如果一个指针变量p指向一个数组a，那么p[2]=*(p+2)=a[2]
      如何创造一个动态数组：    int*p=（int*）malloc（4*5），这串代码就是创造了一个动态数组p，每个元素是4字节，有五个元素
      这时候p[0]就是那个动态数组中的第一个元素，p[1]就是那个动态数组中的第二个元素
      每个元素是多少字节主要看强制转换时转换成了什么数据类型的数组，当然这个5也可以用一个变量表示，然后变量用scanf输入赋值
      这样就可以随时变化数组长度，并且可以随时终止和使用这串数组了，完美解决了静态数组的缺点
      使用for循环+scanf/printf还可以将一维数组里面的每个元素进行赋值或输出 
116.如何扩大动态内存：   realloc（p 100）；   比如p本来指向的动态内存占50字节，这个代码就可以将那块内存变成100字节，并且保留前50字节的数据
     如果p本来指向的动态内存占200字节，那么这串代码可以把那块内存变成100字节，并且保留前100字节的数据
117.动态内存与静态内存的比较
       静态内存是由系统自动分配的，由系统自动释放
       动态内存是由程序员手动分配的，手动释放
       静态内存是由栈分配的（参考91），动态内存是由堆分配的（堆可以理解为在栈外面的一个土堆，不受栈影响，所以在任何函数都可以使用他）
118.多级指针（套娃指针）
      int i                    这里就是套娃指针，i是int类型的，p这个指针变量指向i，那么p的前缀就得是int，由于p是个指针，所以要加个*，那么数据类型就是int*
      int *p=&i           而k要指向p，p是int*类型的，所以k的前缀得是int*，由于k得是个指针，所以前缀后面还要加个*
      int **k=&p      可以理解为int*是要指向的变量的数据类型，后面那个*表示这个变量是指针变量
   所以int**k=&p可以说成p是int*类型的，所以前缀是int*，k是个指针变量，所以后面还要加个*
   同时这里的等价关系就变成**k=i，因为k是指向p的，所以*k=p，因为p指向i，所以*p=i，又由于*p=**k，所以**k=i（指针有指向时，保证数据类型一样）
    p是int*类型，*k才是int*类型，保证数据类型一样，这时候*k=p  【关键】
   注意，这里的k不能保存i的地址，因为k是int**类型的，只能存放int*类型的地址
119.如果你在主函数里定义一个int *p，你如果是想把p的值发送给自定义函数，那么自定义函数就只需要定义int *k，因为你发送的是p的值，也就是发送p
       f（p），p的类型是int*，那么k的类型也得是int*，但如果你想发送p的地址，p是int*类型，&p就是int**类型，所以自定义函数得写int**k，这样才能
      保证两者数据类型一样，都是int**类型
    关键：要搞清楚你要发送的是值还是地址，如果你是想在自定义函数里跨函数修改值，就要发送地址，如果只是想把这个值在自定义函数中处理，就发送值
    如果发送的是地址调用时就要写fas（&p），同时要注意&p和k的数据类型要一致
    如果发送的是值，那么就要写fas（p），同时要注意p和k的数据类型要一致
120.malloc后面的括号尽量不要写成具体数字，因为不同程序规定不同，不是每个程序的int都是4字节，尽量按程序来
        使用sizeof来读取int类型的大小，避免了每个程序都申请4字节，但是某些程序装不下int类型的值的情况

  **k = 5;   注意这里，由于p是一级指针，读取p所执行的内存空间要用*p，所以这里是要改变*p的值，而*p是int类型的，所以这里也要用**k来保证类型一致
   这样**k才可以改变*p

假如自定义函数是写了个int i=5之类的静态内存，那么在函数执行完后i的空间就被释放掉了，即使主函数中p指向i，由于i的空间没了，
p也无法读取i地址里面的内容，这时候输出*p来读取p所指向的内容也没用了，所以静态内存i就不能够跨函数使用了   【149】
121.如果要跨函数更改变量，一定要使用指针，并且主函数发送给自定义函数的变量一定要是&p而不能是p，因为发送p的地址才能够让自定义函数对p本身
       进行操作更改，如果是发送p的话只是发送了p的值，自定义函数是对p的值进行操作，并没有对p造成影响
122.结构体的作用：不会乱执行代码，防止会出现执行完第一个学生的age后跳到执行第二个学生的score去了的情况
     struct +名字是这个整体是一个新的数据类型，叫结构体，写在后面的才是变量  【151/155】
123.      struct student a = {18,66.6,'y' };       //第一种定义方法：直接定义变量+赋值 
      struct student b;   	 //第二种方法，先定义变量，然后再一一赋值 （这种方法更好）
       b.age = 20;    //敲完b后敲.会弹出框框来辅助你选择要填哪一个结构体元素的值的 （如果没有提示，就先编译再继续写，每次重新打开都要编译一次）
       b.score = 80;   	//记住：变量+结构体元素才是变量名称 
       b.sex = 'x';   	//使用char一定不要忘记加单引号 
      printf("%d  %f  %c", b.age, b.score, b.sex);    //注意括号里面取变量是要写b.age，不是光写b，要把结构体元素加上才是一个完整的变量  【151/155】
124.struct student 
	{
		int age;           //这里面的age，score之类的也是后面定义的变量的名称的一部分 
		float score;
		char sex;
	};   //结构体不是函数，大括号后面记得加上分号          【151/155】
125.如何更改结构体变量的值
  a.age = 22.5f;         第一种更改方式：直接选择a中的age结构体进行更改，由于22.5系统默认为double类型，在数字后面加个f或F可以让他变成float类型 
	
   struct student *p = &a;       第二种方法：利用指针修改，注意a是struct student类型，&a就是struct student*类型，所以p也得是struct student*类型 
   p->age = 66;                                          p->age的含义就是对p所指向的结构体变量中的某一个元素进行操作，比如这里p->age = （*p）.age = a.age 
	            			   也就是把p所指向的结构体a中的age的值变成了66（重点）     【151/155】             （上面的括号不能省）
126.输入字符串时，不能直接输入，要利用strcpy，比如char i[5],这样就然后对i输入一段字符的时候，要写成strcpy（i ，“张三”）；
       注意点一：使用strcpy时，要在程序最开始写上#include<string.h>
       注意点二：strcpy后面记得加上括号，分号写在括号外面
       注意点三：输入字符串的时候别忘记使用大括号，创建字符串变量i时，后面括号内的数字一定要刚好符合你输入的字符串，比如这里就刚好5个char
	        就可以搞定，不能定义成char i[66],这么大的数字（一个中文是2字节，俩个中文就四字节，再加上末尾的\0就是五字节）
       注意点四：输入字符串时要将=换成逗号，也就是将i =“张三”替换成i ，“张三”  不能够使用等号来赋值
127.如何利用指针与结构体互通
      创建结构体struct student a，然后将a的地址发送给函数void inputstudent(struct student *b)，inputstudent (&a)，让b接收a的地址，
      之后就可以利用b->age，(*b).sex，strcpy(b->name,"。。")等语句实现对a的修改，待主函数中的input函数执行完后，接着将a发送给c 
       outputstudent(a);  void outputstudent(struct student c)，由于主函数中已经执行完input语句，所以a的值已经被b给更改了，所以output语句中
       只需要输出a的值就可以了，所以直接发送a的值到函数c中就行，由于不用通过c更改a，所以c不用使用指针变量
  所以说：结构体就相当于是很多个变量的合体，通过发送结构体变量的地址，就相当于一次发送了很多变量的地址，就可以在一个函数中实现对多个变量的
                修改，不用说把每个变量都要发送一次给自定义函数，直接发送结构体就可以了                        【159】
128.结构体中创建的变量不能+-*/，但可以相互赋值
       比如 struct student a，b           a=b或b=a都是可以的，但a*b，a+b都是错误的
129.冒泡排序
    for(i=0; i<n-1; i++)       //第一个for循环是用来确认要循环多少次的 
{
	for(j=0; j<n-1-i; j++)     //第二个for循环使用来确认某次比较时比较到a[几]就停止继续比较，转入下一次循环的 
	{
	if(a[j]<a[j+1])      //冒泡排序思路：比如这里有五个数字，第一第二个比，小的那个放到后面去，第二第三个比，小的那个放到后面去
	{	          //这样下去，每次比较都是把小的放到后面，每次比较都是用前一次比较小的那个数字拿来比较的，所以当最后一次比较完成后 
	     t = a[j];         //所有数字中最小的那个就放到最后面了，之后把最后那个最小的数字剔除掉，比较剩下的4个数字，再用同样的方法把最小的 
	     a[j] = a[j+1]; //那个数字放到最后面（如果算上那个被剔除的最小数字，第二次比较的最小的数字就在倒数第二位），以此类推下去， 
	     a[j+1] = t;    //找出5个数字中的最值要比较4次，找出4个数字的最值要比较3次，所以第一次循环要比较4次，第二次循环要来3次。。   
	}                         //给5个数字排序要循环4次，第一次找5个数字最值放到最后面，第二次找4个数字最值放到后面。。。     
	else ;
	}
}
130.p =  (struct student*)malloc(n*sizeof(struct student));          这里就是创建了n个结构体，且都是以动态内存形式储存的，同时p指向这多个结构体 
       如果指针p指向多个结构体，每个结构体都是动态内存，那么p[2]=*(p+2)=a[2]，结构体本质上和数组是一样的，比如p[0].age就是指第一块动态内存
      中的结构体中的age变量，也就是第一个学生的age变量（参考115），结构体和数组其实非常相似，结构体中的age，sex其实就是数组的第1.2个元素
       记住，如果指针p指向一个数组或多个结构体或多块动态内存，那么p[0]就是数组第一个元素或第一个变量的结构体或第一块动态内存的内容，p[0].age
       就是指第一个变量的结构体中的age数据（第一个学生的age数据/第一个结构体中的age元素的数据）
       如果指针p指向一块动态内存，那么*p就表示那一块动态内存

       用char a[100]这样定义的字符串，才scanf输入的时候不用加取地址符，因为本质上a就是一个存放字符串的数组了，这个数组名本身就是首元素的地址

       if(p[k].score >p[k+1].score )                          p[k]指的是p所指向的那个结构体，结构体本身是不能比较大小的，所以要写成p[k].score 
			                             这样就变成具体比较两个结构体中的score元素的大小 
        t = p[k];
        p[k] = p[k+1];                        注意这里是交换的结构体，不只是单单交换两个结构体中的score数据，这里是把两个结构体整体给换了内存空间
        p[k+1] = t;			【实战4】
131. 什么是枚举：把一个事物所有可能的取值一一列举出来
        枚举与结构体类似，默认枚举内的第一个元素代号是0（也就是当变量值为第一个元素的时候，输出结果会是0），除非在枚举中给第一个元素单独赋值
        枚举的最后也要加上分号，同结构体一样，并且enum+（）也只是一个数据类型，不是变量     【166】
132.原码，补码，反码，移码
       原码：保存时以0为正，1为负，比如保存-5，-号就用1表示，5就是0101，那么保存时的二进制就是10101
                 原码简单易懂，但非常复杂，运算难度高，没有啥用，直接忽略
       反码：正数的反码还是等于原码，负数的反码就是他的原码除符号位外，按位取反。
                 比如： 3是正数，反码与原码相同，则可以表示为0011，-3的原码是1011，符号位保持不变，低三位（011）按位取反得（100）
                 所以-3的反码为1100（反码是用来解决原码保存时2+（-2）不等于0的问题），反码也没啥用，直接忽略
       移码：就是表示数值平移n位，n为移码量，用于浮点数的阶码的存储
       补码：用于区别正负数的存储，同样的以0为正，1为负，补码具体存储负数的操作如下         
                 1.求其对应正数的二进制编码（前面加上0表示现在转换的是正数的二进制编码）
                 2.将所有位取反（每一位的0变1，1变0）                                                                  口诀：取反后加1再前补1
	 3.末尾加1（比如100就变成101，101就变成110）
 	 4.位数不够时，左边补1（比如该负数是整形，最后只要、有101三个数字，但整形是4字节，就在左边补1，变成11111.....101，前面有30个1）
	    位数够不够看该负数是什么数据类型的，那个数据类型占几字节，保存的二进制代码就得补够多少字节，比如int类型的就要补够32位二进制代码
        举例：保存-3，第一步3的二进制编码为11，前面补0变成011，第二步交换，011变成100，第三步加1，100变成101，第四步补位，101变成11....101
133.为什么第一步前面要加上0：是为了方便后面的转换，比如3你就写成11二进制代码，转换后是00，加1后是01，前面补1后还是1101，在第一步就加上
                                                 是为了方便后面的步骤，当然你不加也可以
134.为什么32位和64位电脑的int类型都是4字节：首先要明确int的字节数绝对不能超过long int类型，当电脑是64位的时候，由于64位=8字节，所以
                                                                          long int也只能是8字节，那么int就不可能是8字节，只能是4字节
135.大数字如何转化为二进制：先转为16进制，再转为2进制
        比如-100，其正数100先转为16进制就是64，再分别转为2进制，6就是0110（8421法则），4就是0100，那么100的二进制代码就是01100100，
        然后再全反变成10011011，然后末尾加1变成10011100，然后前面补1补够32位就行
136.补充：求正整数的补码就直接除2取余，然后倒序排列就行                     0的二进制就是0
137.二进制如何转换为十进制：
    第一种：首位是0的时候-比如00111011，4位一组，第一组1011就是11（8421法则），第二组0011有两种处理方法，第一种就是2^4*1+2^5*1(不推荐)
                 第二种就是直接使用8421法则，那么0011就是3，然后再乘16，就是48，那么这串二进制代码的十进制就是48+11=59，本质上就是先转成
                 十六进制再转成十进制，也就是
138.进制转换并以补码形式储存大总结        
 n进制转化为十进制：就直接n^0..+n^1..+n^2这样下去，特别的，首位是1的二进制转化为十进制要先转为十六进制再转为十进制，具体操作是：全部取反，
		末尾+1，4个一组，用8421法则转为十六进制，然后在用十六进制转为十进制的方法（第一行）来转换。
		比如十六进制的64就是普通情况，就直接16^0*4+16^1*6=100。
		比如11....10011011，首先知道是特殊情况（首位是1），然后取反是00....01100100，末尾+1就是00....01100101，4位一组，
		运用8421法则变成十六进制就是65，然后再变成十进制就是16^1*6+16^0*5=101
十进制转为n进制：转为几进制就除几，取余然后倒序排列。特别的，转为二进制的时候，如果数字较大，先转成十六进制再转为二进制。除此之外，如果
                             十进制的是个负数，要算其正数二进制代码，然后取反加一，前面用1补齐32/64位
	 比如：-100的正数是100转成十六进制就是64，再转成二进制就是01100100，然后全反后加一，前面补齐32/64位就是-100的补码了（详见135）                        
二进制转为十六进制：四个为一组，运用8421法则转换
                            比如：00101110，就分成两组，第一组是0010，对应2^1*1=2，第二组1110，对应2^3*1+2^2*1+2*1+2^0*0=14(E)
                                      那么这串二进制代码的十六进制形式就是2E
十六进制转为二进制：从右向左，把一个数字劈成四个，运用8421法则，分别写出每一个数字的二进制代码
                               比如：A1，A就是十六进制表示的10，10的二进制代码就是1010；1就是0001，所以A1的二进制代码就是10100001
总结：二进制与十进制的转换要区分正负，二进制1开头是负。负数的转换要取反加一再补1（十转二），取反加一变十六进制，再转为十进制（二转十）
          转为十进制（除二进制负数）的就用n^0..+n^1..+n^2这样下去，十进制转为n进制（除二进制）就除n，然后取余倒序
          二进制与十六进制/十进制的转换要使用8421法则，二转十六就以4个代码为一组，分别乘8421相加，十六转二就把每一个数字换成二进制，
          即用8421法则，分别表示每一个数字（8421法则适用于十进制于二进制，只是可以把十六进制看成十进制，所以这里也可以用8421法则）
          二进制和十进制的转换往往要借助十六进制当中间商，把十六进制看成十进制会更好理解，比如十六进制的A其实就是十进制的10
139.如果以十六进制给一个变量赋值，要在前面加上0X，比如i = 0XFFFFFFFB；
140.已知128的二进制是000...10000000，十六进制是80，如果char ch = 0X80，那么输出结果会是-128
       原因：ch只能存放一个字节，那么把128的十六进制赋给ch后，ch接收到的二进制代码会丢失前面的24个0，只会保留后面8个数字（10000000）
                 该串二进制代码是1开头的，所以计算机就会读出一个-128
141.二进制代码从01111.....1111后就是负数了，所以int类型能存储的最大正整数是二进制011111.....11111（十六进制7FFFFFFF）（十进制127）
       最小的负整数就是二进制1000....0000（十进制-128）（十六进制80000000），因为从1000....000后负数就在变大了（-128   -127   -126）
142.算法                                    【174-175】
       通俗定义：解题的方法和步骤
       狭义算法：对存储数据的操作，对不同的存储结构，要完成某一个功能所执行的操作是不一样的
	        比如：输出数组中的每一个元素，和输出链表中的每一个节点的操作是不一样
                        这说明：算法是依附于存储结构的，不同的存储结构，所执行的算法是不一样的，所以当涉及算法的时候，一定要先想数据是怎么样存储的
                        比如数组是连续存储的，而链表是不连续存储的，以此为基础，利用算法解决问题
      广义算法：广义的算法也叫泛型，泛型就是无论数据如何存储，对数据的操作都是一样的
                       具体来讲，就是通过函数，来确保不同存储方式的数据都可以通过相同的代码进行处理
                      比如：数组和链表的存储方式就不一样，输出数组时，只需要*p，p++就可以表示数组内的元素了，但在链表中不可以
                       但是在c++语言中，可以把++定义成一个函数，在函数内部写上p=p->pnext就可以确保数组和链表执行p++的语句时都可以表示下一元素
143：至少有两种结构可以存储数据：数组和链表
        链表就解决了数组的缺点：数组一定要是连续的储存空间，你如果删除数组中的某一个元素，后面的元素要上来填住空间，确保元素是连续的
         但链表可以是不连续的，他是由内容+地址组成的一块空间，内容储存的就是类似数组内的元素，地址就是下一块空间的地址，这样删除一块链表空间
        就只是删除了他的内容，并不会影响他保存的下一块空间的地址，也就不需要移动空间了。但链表也有缺点，就是调用他的某一块空间的时候不能直接
         使用指针调用那块内存，也就是不能像数组一样直接用*（a+3）这样来找到第4个元素
144.链表的专业术语
       头指针：存放头结点地址的指针变量
       头结点：目的是为了方便对链表进行操作，头结点的数据类型和首节点的数据类型是一样的，头结点是首节点前面的哪个节点，头结点不能存放有效数据
       首节点：存放第一个有效数据及下一个节点地址的节点
       尾节点：存放最后一个有效数据的节点，其存放的地址为空（Null）
即   头指针->头结点->首节点->尾节点
145.确定一个链表只需要知道头指针一个参数，因为知道头指针就知道头结点，头结点的下一个节点就是首节点，一直往下读取，其存放地址为空的节点就是
       尾节点
       制作一个链表：结构体+函数+指针
       不要想复杂了，结构体其实就是一个数据类型，pone->pnext这种结构体里面的元素其实就是一个变量

       createlist()表示执行createlist这个函数
       phead = createlist()表示把createlist函数执行结果的返回值赋给phead
       traverselist(phead)表示把phead发送给createlist函数，对phead执行函数内的语句

       while( NULL != p)   //   ！=就是不等于的意思   NULL是空的意思          【173，把程序背下来】
146.位运算符
       &：把他们二进制的每一位进行比较，判断每一位的真假并返还0/1代码（类似于&&且，只要有一个0就是假，必须要是两个1才是真）
              注意和取地址符区别开，取地址符变量是在&后面（&i），按位与在&两边都有变量（i&k）
              同时也要和&&区别开，这个时逻辑运算符，是并且的意思，其结果只有真假（1真0假）
              比如5&7，二进制就是0101和0111，他们的个位都是1，1和1都是真，那么结果就是个位是真（只要没有0就是真，有一个0就是假），也就是1，
              十位是0和1，因为有一个0，所以十位是假，也就是0，最终比较完每一位后得到的数据就是0101，也就是5，所以5&7的输出结果就是5
              用处：用于信息采集，比如a变量，我要知道他的第一位二进制代码是几，就可以写a&0101，看结果是0还是1，如果是0那么个位就是0，反之是1
        |：类似于||或，必须要有两个0才是假，只要有一个1就是真，与&一样也是把二进制的每一位进行比较
	老规矩，要与逻辑运算符||区分开，||是或的意思         【或：两个0才是假；且：两个1才是真】
        ~：按位取反，变量在~后面，比如~i，i=1就是0001，取反就是1000，前面补1，前面补几关键看i是正数还是负数，i是正数他前面本来就是0，取反后
              前面就都是1了
        ^：按位异或，相同为0，不同为1，比如44^66=1，4^4=0
        <<：按位左移，也就是乘2（推理，十进制的2左移一位就是20，也就是乘10，那么二进制左移一位也是乘2）
               左移n位相当于乘2的n次方，比如左移3位就是*2*2*2也就是乘2的3次方
	比如i=3，i<<3就是左移3位，那么输出结果就是3*2^3=24
               注意：i=i*8和i=i<<3的结果都是24，但是i=i<<3的执行速度会更快，因为适用*会调用乘法器，再处理数据，但<<是直接处理数据，不用调用工具
        >>：同理这个就是右移
                注意不管左移右移，空出的位置可能补1也可能补0，因为分算数移动和逻辑移动两种情况
                比如左移后右边就会空位置，如果数据的个位（最右边那个数字）是1，那么右边就补1，当然也可能是不管最右边是0还是1，全部都补0
                注意：不要移过多导致有效数据丢失
147.break终止的是离他最近的且没有被终止的循环
        比如    for（i=0；i<4; i++）		显然，这里的执行到break的时候，while循环已经自动终止了
 	    {  while(i)			所以这里终止的是for循环
		printf("ahh");
                       break}
148.指针p必须要指向一个明确的内存空间后才能通过修改*p来改变它所指向的内存空间的内容
       比如  int*p   *p=10就是错的，因为没有像p=&i这样的代码，就是说p没有指向一块明确的内存空间，它指向的是一个垃圾值，不能对垃圾值进行更改
149.if			
                if
	else		这里的else与第二个if对应
      else			这里的else与第一个if对应
        因为中间那个if和else是一个整体，这一个整体在第一个if里面是一个语句
150.算数运算符>关系运算符>逻辑运算符>赋值运算符 
        +-*/           <   <=  ==    &&    ||	 +=    /=    
151.a+1=b这个关系要记住，c语言计算字母的时候会自动把字母变成ASCII码来计算     A=65       a=97
152.注意：自定义函数中定义的形参p虽然接收了主函数中的某个变量的地址，但是如果只是对p进行操作的话仍然是在自定义函数中进行的操作，不会影响
       到主函数，只有对*p进行操作的时候才能同步改变主函数中那个变量的值
153.二进制全部为0的含义   《==》   000000000000000的含义
       	一：数值为0
	二：字符串的结尾标识符“\0”
	三：空指针NULL
	       NULL的本质是也是0，指的是内存单元的编号是0，也就是地址的编号是0，这个0不是数字0，而是地址0
                        计算机规定，编号是0的内存区域不可访问也不可读写，因为这块区域里面放着核心代码，更改它会使整个系统崩溃
                      比如p=NULL，就不能写*p去读取编号为0的内存内容了
154.什么是分配释放内存：将一块区域的控制权限交给操作系统/将控制权限收回来，分配和释放内存不会删除内存空间，只会改变控制权限
       例如：int i=5，就是操作系统先分配一块空闲空间，将它与i关联，后通过操作这块空间来控制i，把5给存储到这块空间中来
155.空格和回车就是字符，字符的含义就是一个命令，比如\0或\n就是一个字符
       scanf（“%d”，&a）  //输入数字赋给a
       scanf（“%d”，&b）  //由于上面输完数字之后敲了回车，这里这个b的作用就是接收那个回车/r,用于吞掉那个回车
       scanf（“%d”，&b）  //此时回车已经给吞掉了，就可以对b再次赋值
156.除了强制转换，也可以使用四则运算改变数据类型
      如：char n=A
             int m=n+0      //则m为65(A),这里+0把n给强制转换为整型了
157.除了printf和scanf，也可以使用下面的语句来输入输出
       c=getchar（a）      //输入一个字符a给c
       putchar（c）         //输出c
       getchar只能接收一个字符，不好用，一般不用
158.abs求整数绝对值      fabs求实数绝对值
       例如int abs（int n）就是求n的绝对值
        使用上面两个语句记得写include <stdlib.h>
       使用下面的语句记得写include<math.h>
       double sin(double n)                           求sin（n）
       double pow (double x，double y)     求x的y次方
       double exp(double x)                       求e的x次方
       double log(double x)                        求lnx
       double log5(double x)                      求log5x
159.scanf中以逗号隔开，自己输入的时候就也要以逗号隔开  ，如 %d，%d那么输入的时候就一定要是12，13      不能以空格隔开
       但如果scanf中没有隔开，自己输入的时候可以打空格    %d%d 那么输入的时候可以使用tab，空格回车隔开都可以成功输入
160.宏定义   #define pi=3.14    
       就是pai是个无限不循环小数，这里用宏定义把它定义成一个常数3.14，这样以后输入pai计算的时候就不会是无限不循环小数了，pai就是个常数
161.    printf（“%4.2f”）的意思就是用4个字节输出，保留小数点后两位，以浮点数形式输出
           用几个字节保存+小数点+保留小数点后几位+以什么数据类型输出
162.打两个运算符才能输出运算符，比如i=2；  printf（"%d"）输出的就是一个整形变量的值    2
       但是i=2；   printf（“%%d”）    输出的结果就是     %2
163.交换两个数字除了用定义新变量三连以外，还可以使用求和的方法
      例如  a=2     b=5
              a = a + b = 2 + 5=7
              b = a - b = 7 - 5 = 2
              a = a - b = 7 - 2 = 5
164.









	















